import { crc32 } from 'crc';
import EventEmitter from 'event-emitter';

// combine the user-supplied options with the referencing base options
function combine(object, options, whitelistedKeys) {
  Object.keys(object).forEach((key) => {
    if (object[key] instanceof Object) {
      combine(object[key], options, whitelistedKeys);
    } else if (options[key] !== undefined && whitelistedKeys.indexOf(key) >= 0) {
      object[key] = options[key];
    }
  });
}

class TG {
  constructor(client) {
    this.client = client;
  }

  /*
   *  Send text message to an existing chat.
   *  Method "parseTextEntities" requires TDLib 1.1.0 (git.io/tdlibchanges).
   */
  async sendTextMessage(args = {}) {
    const { $text, ...options } = args;
    if (!$text) {
      throw new Error('No text defined for method "sendTextMessage".')
    }
    const payload = {
      '@type': 'sendMessage',
      'chat_id': 0,
      'reply_to_message_id': 0,
      'disable_notification': false,
      'from_background': true,
      'reply_markup': null,
      'input_message_content': {
        '@type': 'inputMessageText',
        'text': await $text._format(this.client),
        'disable_web_page_preview': true,
        'clear_draft': true,
      },
    };
    combine(payload, options, [
      'chat_id', 'reply_to_message_id', 'disable_notification', 'from_background',
      'disable_web_page_preview', 'clear_draft',
    ]);
    return this.client.fetch(payload)
  }

  /*
   *  Send photo message to an existing chat.
   */
  async sendPhotoMessage(args = {}) {
    const { $caption, ...options } = args;
    const payload = {
      '@type': 'sendMessage',
      'chat_id': 0,
      'reply_to_message_id': 0,
      'disable_notification': false,
      'from_background': true,
      'reply_markup': null,
      'input_message_content': {
        '@type': 'inputMessagePhoto',
        'photo': {
          '@type': 'inputFileLocal',
          'path': null,
        },
        'thumbnail': null,
        'added_sticker_file_ids': [],
        'width': 0,
        'height': 0,
        'caption': $caption ? await $caption._format(this.client) : null,
        'ttl': 0,
      },
    };
    combine(payload, options, [
      'chat_id', 'reply_to_message_id', 'disable_notification', 'from_background',
      'path', 'thumbnail', 'added_sticker_file_ids', 'width', 'height', 'ttl',
    ]);
    return this.client.fetch(payload)
  }

  /*
   *  Send sticker message to an existing chat.
   */
  async sendStickerMessage(args = {}) {
    const { $caption, ...options } = args;
    if (!options.path || !options.path.endsWith('webp')) {
      throw 'WebP image must be passed for [sendStickerMessage] method'
    }
    const payload = {
      '@type': 'sendMessage',
      'chat_id': 0,
      'reply_to_message_id': 0,
      'disable_notification': false,
      'from_background': true,
      'reply_markup': null,
      'input_message_content': {
        '@type': 'inputMessageSticker',
        'sticker': {
          '@type': 'inputFileLocal',
          'path': null,
        },
        'thumbnail': null,
        'width': 0,
        'height': 0,
      },
    };
    combine(payload, options, [
      'chat_id', 'reply_to_message_id', 'disable_notification', 'from_background',
      'path', 'thumbnail', 'width', 'height',
    ]);
    return this.client.fetch(payload)
  }

  /*
   *  Get all chats.
   */
  async getAllChats() {
    let { chat_ids: chats } = await this.client.fetch({
      '@type': 'getChats', 
      'offset_order': '9223372036854775807',
      'offset_chat_id': 0,
      'limit': Math.floor(Math.random() * 9999999),
    });
    chats = chats.map((chatId) => this.client.fetch({
      '@type': 'getChat', 
      'chat_id': chatId,
    }));
    chats = await Promise.all(chats);
    return chats
  }

  /*
   *  Update user's username.
   *  Method "checkChatUsername" requires TDLib 1.2.0 (git.io/tdlibchanges).
   */
  updateUsername(username, supergroupId = null) {
    return new Promise(async (resolve, reject) => {
      let payload;
      // Check the username
      payload = { '@type': 'checkChatUsername', username };
      if (supergroupId) {
        const { id } = await this.client.fetch({ '@type': 'createSupergroupChat', 'supergroup_id': supergroupId });
        payload['chat_id'] = id;
      } else {
        const { id } = await this.client.fetch({ '@type': 'getMe' });
        payload['chat_id'] = id;
      }
      const { '@type': checkResult } = await this.client.fetch(payload);
      if (checkResult !== 'checkChatUsernameResultOk') {
        return reject(checkResult)
      }
      // Update the username
      payload = { '@type': 'setUsername', username };
      if (supergroupId) {
        payload['@type'] = 'setSupergroupUsername';
        payload['supergroup_id'] = supergroupId;
      }
      const result = await this.client.fetch(payload);
      resolve(result);
    })
  }

  /*
   *  Opens a secret chat with given user ID.
   */
  async openSecretChat(userId) {
    let secretChat = await this.getAllChats();
    secretChat = secretChat.find(({ type: { '@type': type, user_id: user } }) => {
      return type === 'chatTypeSecret' && user === userId
    });
    // created already
    if (secretChat) {
      return secretChat
    }
    // create new secret chat
    secretChat = await this.client.fetch({
      '@type': 'createNewSecretChat',
      'user_id': userId,
    });
    return secretChat
  }

  /*
   *  Close and remove a chat.
   */
  async deleteChat(chatId) {
    const chat = await this.client.fetch({
      '@type': 'getChat',
      'chat_id': chatId,
    });

    let payload = {};
    switch (chat.type['@type']) {
      case 'chatTypeBasicGroup':
      case 'chatTypeSupergroup': {
        const { id } = await this.client.fetch({ '@type': 'getMe' });
        payload['@type'] = 'setChatMemberStatus';
        payload['user_id'] = id;
        payload['chat_id'] = chat.id;
        payload['status'] = { '@type': 'chatMemberStatusLeft' };
        break
      }
      case 'chatTypeSecret': {
        payload['@type'] = 'closeSecretChat';
        payload['secret_chat_id'] = chat.type.secret_chat_id;
        break
      }
      default: {
        payload['@type'] = 'closeChat';
        payload['chat_id'] = chat.id;
        break
      }
    }
    await this.client.fetch(payload);
    await this.client.fetch({
      '@type': 'deleteChatHistory',
      'chat_id': chat.id,
      'remove_from_chat_list': true,
    });
  }

  /*
   *  Get chat by username or id
   */
  async getChat(args = {}) {
    const { username, chat_id } = args;
    let chat = {};
    if (username) {
      chat = await this.client.fetch({
        '@type': 'searchPublicChat',
        username,
      });
    } else if (chat_id) {
      chat = await this.client.fetch({
        '@type': 'getChat',
        chat_id,
      });
    } else {
      throw new Error('Neither username nor chat_id were specified for method "getChat"')
    }
    return chat
  }

  /*
   *  Download a file
   */
  async download(remoteFileId) {
    const { id } = await this.client.fetch({
      '@type': 'getRemoteFile',
      'remote_file_id': remoteFileId,
    });
    let file = await this.client.fetch({
      '@type': 'downloadFile',
      'file_id': id,
      'priority': 1,
    });
    if (!file['local']['path'].length) {
      const downloadPromise = new Promise((resolve) => {
        this.client.downloading[id] = resolve;
      });
      file = await downloadPromise;
    }
    return file
  }


  /*
   *  Call an user
   */
  call(userId) {
    return new Promise(async (resolve, reject) => {
      try {
        const { id } = await this.client.fetch({
          '@type': 'createCall',
          'user_id': userId,
          'protocol': {
            '@type': 'callProtocol',
            'udp_p2p': true,
            'udp_reflector': true,
            'min_layer': 65,
            'max_layer': 65,
          },
        });
        const emitter = EventEmitter();
        this.client._hijackUpdate('updateCall', (update) => {
          // If call failed due to USER_PRIVACY_RESTRICTED
          if (update.call.state['@type'] === 'callStateError') {
            this.client._hijackUpdate('updateCall', false);
            return reject(update.call.state.error)
          }
          if (update.call.state['@type'] === 'callStateReady') {
            emitter.emit('ready', update.call);
          }
          if (update.call.state['@type'] === 'callStateDiscarded') {
            emitter.emit('discarded', update.call);
            this.client._hijackUpdate('updateCall', false);
          }
          return resolve(emitter)
        });
      } catch (err) {
        reject(err);
      }
    })
  }
}

var version = "3.0.5";

class InvalidCallbackError extends Error {
  constructor(eventName) {
    super();
    this.message = `"${eventName}" is not a valid callback.`;
  }
}

class InvalidBotTokenError extends Error {
  constructor() {
    super();
    this.message = 'Provided Bot Token is not valid';
  }
}

class ClientCreateError extends Error {
  constructor(error) {
    super(error);
    this.message = `Unable to create client: ${error.message}`;
  }
}

class ClientNotCreatedError extends Error {
  constructor(error) {
    super(error);
    this.message = 'Client is not created';
  }
}

class ClientFetchError extends Error {
  constructor(update) {
    super();
    this.message = JSON.stringify(update);
  }
}



var index = /*#__PURE__*/Object.freeze({
  __proto__: null,
  InvalidCallbackError: InvalidCallbackError,
  InvalidBotTokenError: InvalidBotTokenError,
  ClientCreateError: ClientCreateError,
  ClientNotCreatedError: ClientNotCreatedError,
  ClientFetchError: ClientFetchError
});

class Client {
  constructor(mode, options = {}) {
    const defaultOptions = {
      apiId: null,
      apiHash: null,
      verbosityLevel: 2,
      tdlibParameters: {
        'enable_storage_optimizer': true,
        'use_message_database': true,
        'use_secret_chats': true,
        'system_language_code': 'en',
        'application_version': '1.0',
        'device_model': 'tglib',
        'system_version': version,
      },
    };
    this.options = {
      ...defaultOptions,
      ...options,
    };
    this.ready = new Promise((resolve, reject) => {
      // Add some delay to allow telegram get ready. (Issue #20)
      this.resolver = () => setTimeout(resolve, 500);
      this.rejector = reject;
    });
    this.client = null;
    this.tg = new TG(this);
    this.hijackers = {};
    this.downloading = {};
    this.fetching = {};
    this.callbacks = {
      'td:update': () => {},
      'td:error': () => {},
      'td:getInput': () => { throw new Error('td:getInput callback is not set.') },
    };
    this.init();
  }

  registerCallback(key, callback) {
    const validNames = Object.keys(this.callbacks);
    if (validNames.indexOf(key) < 0) {
      throw new InvalidCallbackError(key)
    }
    this.callbacks[key] = callback;
  }

  async loop() {
    if (!this.client) {
      // when client has been destroyed, stop the update loop
      return
    }
    const update = await this._receive();
    if (update) {
      if (this.hijackers[update['@type']]) {
        // for tglib update hijacking
        this.hijackers[update['@type']](update);
      } else {
        // handle update normally
        switch (update['@type']) {
          case 'updateAuthorizationState': {
            await this.handleAuth(update);
            break
          }
          case 'error': {
            await this.handleError(update);
            break
          }
          default:
            await this.handleUpdate(update);
            break
        }
      }
    }
    setTimeout(() => this.loop(), 1);
  }

  _hijackUpdate(type, callback) {
    if (typeof callback === 'function') {
      this.hijackers[type] = callback;
    } else {
      delete this.hijackers[type];
    }
  }

  async handleAuth(update) {
    switch (update['authorization_state']['@type']) {
      case 'authorizationStateWaitTdlibParameters': {
        this._send({
          '@type': 'setTdlibParameters',
          'parameters': {
            ...this.options.tdlibParameters,
            '@type': 'tdlibParameters',
            'api_id': this.options.apiId,
            'api_hash': this.options.apiHash,
            'database_directory': this.options.databaseDir,
            'files_directory': this.options.filesDir,
          },
        });
        break
      }
      case 'authorizationStateWaitEncryptionKey': {
        this._send({ '@type': 'checkDatabaseEncryptionKey' });
        break
      }
      case 'authorizationStateWaitPhoneNumber': {
        const type = await this.callbacks['td:getInput']({
          string: 'tglib.input.AuthorizationType',
        });
        const value = await this.callbacks['td:getInput']({
          string: 'tglib.input.AuthorizationValue',
        });
        if (type === 'user') {
          this._send({
            '@type': 'setAuthenticationPhoneNumber',
            'phone_number': value,
          });
        } else {
          this._send({
            '@type': 'checkAuthenticationBotToken',
            'token': value,
          });
        }
        break
      }
      case 'authorizationStateWaitCode': {
        const payload = { '@type': 'checkAuthenticationCode' };
        payload['code'] = await this.callbacks['td:getInput']({
          string: 'tglib.input.AuthorizationCode',
        });
        this._send(payload);
        break
      }
      case 'authorizationStateWaitRegistration': {
        const payload = { '@type': 'registerUser' };
        console.log(`User has not yet been registered with Telegram`);
        payload['first_name'] = await this.callbacks['td:getInput']({
          string: 'tglib.input.FirstName',
        });
        this._send(payload);
        break
      }
      case 'authorizationStateWaitPassword': {
        this.authFlowPasswordHint = update['authorization_state']['password_hint'];
        const password = await this.callbacks['td:getInput']({
          string: 'tglib.input.AuthorizationPassword',
          extras: { hint: this.authFlowPasswordHint },
        });
        this._send({
          '@type': 'checkAuthenticationPassword',
          'password': password,
        });
        break
      }
      case 'authorizationStateReady':
        delete this.authFlowPasswordHint;
        this.resolver();
        break
    }
  }

  async handleError(update) {
    const id = update['@extra'];
    if (this.fetching[id]) {
      delete update['@extra'];
      this.fetching[id].reject(new ClientFetchError(update));
      delete this.fetching[id];
      return
    }
    switch (update['message']) {
      case 'PHONE_CODE_EMPTY':
      case 'PHONE_CODE_INVALID': {
        const code = await this.callbacks['td:getInput']({
          string: 'tglib.input.AuthorizationCodeIncorrect',
        });
        this._send({
          '@type': 'checkAuthenticationCode',
          'code': code,
        });
        break
      }
      case 'PASSWORD_HASH_INVALID': {
        const password = await this.callbacks['td:getInput']({
          string: 'tglib.input.AuthorizationPasswordIncorrect',
          extras: { hint: this.authFlowPasswordHint },
        });
        this._send({
          '@type': 'checkAuthenticationPassword',
          'password': password,
        });
        break
      }
      case 'ACCESS_TOKEN_INVALID': {
        this.rejector(new InvalidBotTokenError());
        break
      }
      default: {
        this.callbacks['td:error'].call(null, update);
      }
    }
  }

  async handleUpdate(update) {
    const id = update['@extra'];
    if (this.fetching[id]) {
      delete update['@extra'];
      this.fetching[id].resolve(update);
      delete this.fetching[id];
      return
    }
    switch (update['@type']) {
      case 'updateFile': {
        const fileId = update['file']['id'];
        if (!this.downloading[fileId]) {
          // default handle
          this.callbacks['td:update'].call(null, update);
          return
        }
        if (!update['file']['local']['path'].length) {
          // not yet downloaded
          return
        }
        // resolve downloaded
        this.downloading[fileId](update['file']);
      }
      case 'updateOption': {
        if (update['name'] === 'my_id' && update['value']['@type'] === 'optionValueEmpty') {
          // session has been signed out
          await this._destroy();
          break
        }
      }
      default: {
        this.callbacks['td:update'].call(null, update);
      }
    }
  }

  async fetch(query) {
    const id = crc32(Math.random().toString()).toString();
    query['@extra'] = id;
    const receiveUpdate = new Promise((resolve, reject) => {
      this.fetching[id] = { resolve, reject };
      // timeout after 15 seconds
      setTimeout(() => {
        delete this.fetching[id];
        reject('Query timed out after 30 seconds.');
      }, 1000 * 30);
    });
    await this._send(query);
    return receiveUpdate
  }
}

class ClientWASM extends Client {
  constructor(options = {}) {
    super('wasm', options);
  }

  async init() {
    try {
      const {
        verbosityLevel,
        wasmModule,
      } = this.options;

      // See also:
      // https://github.com/tdlib/td/blob/master/td/telegram/td_emscripten.cpp
      // https://github.com/tdlib/td/blob/master/example/web/tdweb/src/worker.js#L495
      this.tdlib = {
        td_create:        wasmModule.cwrap('td_create', 'number', []),
        td_send:          wasmModule.cwrap('td_send', null, ['number', 'string']),
        td_receive:       wasmModule.cwrap('td_receive', 'string', ['number']),
        td_execute:       wasmModule.cwrap('td_execute', 'string', ['number', 'string']),
        td_destroy:       wasmModule.cwrap('td_destroy', null, ['number']),
      };
      this.tdlib.td_execute(
        0,
        JSON.stringify({
          '@type': 'setLogVerbosityLevel',
          new_verbosity_level: verbosityLevel,
        })
      );

      this.client = await this._create();
    } catch (error) {
      this.rejector(new ClientCreateError(error));
      return
    }
    this.loop();
  }

  async _create() {
    const client = await this.tdlib.td_create();
    return client
  }

  async _send(query) {
    if (!this.client) {
      throw new ClientNotCreatedError()
    }
    const response = await this.tdlib.td_send(this.client, JSON.stringify(query));
    if (!response) {
      return null
    }
    return JSON.parse(response)
  }

  async _receive() {
    if (!this.client) {
      throw new ClientNotCreatedError()
    }
    const response = await this.tdlib.td_receive(this.client);
    if (!response) {
      return null
    }
    return JSON.parse(response)
  }

  async _execute(query) {
    if (!this.client) {
      throw new ClientNotCreatedError()
    }
    const response = await this.tdlib.td_execute(this.client, JSON.stringify(query));
    if (!response) {
      return null
    }
    return JSON.parse(response)
  }

  async _destroy() {
    if (this.client) {
      await this.tdlib.td_destroy(this.client);
      this.client = null;
    }
  }
}

class TextStruct {
  constructor(text, parseMode) {
    this.text = text;
    if (['textParseModeHTML', 'textParseModeMarkdown'].indexOf(parseMode) >= 0) {
      this.parseMode = parseMode;
    }
  }

  // Internal method
  async _format(_client) {
    let args;
    if (this.parseMode) {
      args = await _client._execute({
        '@type': 'parseTextEntities',
        'text': this.text,
        'parse_mode': { '@type': this.parseMode },
      });
    } else {
      args = {
        '@type': 'formattedText',
        'text': this.text,
      };
    }
    return args
  }
}



var index$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  TextStruct: TextStruct
});

export { ClientWASM as Client, index as Errors, index$1 as Structs };
